/* This file was generated by upbc (the upb compiler) from the input
 * file:
 *
 *     pprof.proto
 *
 * Do not edit -- your changes will be discarded when the file is
 * regenerated. */

#ifndef PPROF_PROTO_UPB_H_
#define PPROF_PROTO_UPB_H_
#include "upb.h"
#include "upb.h"
#include "upb.h"
#include "upb.h"
/*
 * Copyright (c) 2009-2021, Google LLC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Google LLC nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL Google LLC BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This is where we define macros used across upb.
 *
 * All of these macros are undef'd in port_undef.inc to avoid leaking them to
 * users.
 *
 * The correct usage is:
 *
 *   #include "upb/foobar.h"
 *   #include "upb/baz.h"
 *
 *   // MUST be last included header.
 *   #include "upb/port_def.inc"
 *
 *   // Code for this file.
 *   // <...>
 *
 *   // Can be omitted for .c files, required for .h.
 *   #include "upb/port_undef.inc"
 *
 * This file is private and must not be included by users!
 */

#if !((defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || \
      (defined(__cplusplus) && __cplusplus >= 201103L) ||           \
      (defined(_MSC_VER) && _MSC_VER >= 1900))
#error upb requires C99 or C++11 or MSVC >= 2015.
#endif

#include <stdint.h>
#include <stddef.h>

#if UINTPTR_MAX == 0xffffffff
#define UPB_SIZE(size32, size64) size32
#else
#define UPB_SIZE(size32, size64) size64
#endif

/* If we always read/write as a consistent type to each address, this shouldn't
 * violate aliasing.
 */
#define UPB_PTR_AT(msg, ofs, type) ((type*)((char*)(msg) + (ofs)))

#define UPB_READ_ONEOF(msg, fieldtype, offset, case_offset, case_val, default) \
  *UPB_PTR_AT(msg, case_offset, int) == case_val                              \
      ? *UPB_PTR_AT(msg, offset, fieldtype)                                   \
      : default

#define UPB_WRITE_ONEOF(msg, fieldtype, offset, value, case_offset, case_val) \
  *UPB_PTR_AT(msg, case_offset, int) = case_val;                             \
  *UPB_PTR_AT(msg, offset, fieldtype) = value;

#define UPB_MAPTYPE_STRING 0

/* UPB_INLINE: inline if possible, emit standalone code if required. */
#ifdef __cplusplus
#define UPB_INLINE inline
#elif defined (__GNUC__) || defined(__clang__)
#define UPB_INLINE static __inline__
#else
#define UPB_INLINE static
#endif

#define UPB_ALIGN_UP(size, align) (((size) + (align) - 1) / (align) * (align))
#define UPB_ALIGN_DOWN(size, align) ((size) / (align) * (align))
#define UPB_ALIGN_MALLOC(size) UPB_ALIGN_UP(size, 16)
#define UPB_ALIGN_OF(type) offsetof (struct { char c; type member; }, member)

/* Hints to the compiler about likely/unlikely branches. */
#if defined (__GNUC__) || defined(__clang__)
#define UPB_LIKELY(x) __builtin_expect((x),1)
#define UPB_UNLIKELY(x) __builtin_expect((x),0)
#else
#define UPB_LIKELY(x) (x)
#define UPB_UNLIKELY(x) (x)
#endif

/* Macros for function attributes on compilers that support them. */
#ifdef __GNUC__
#define UPB_FORCEINLINE __inline__ __attribute__((always_inline))
#define UPB_NOINLINE __attribute__((noinline))
#define UPB_NORETURN __attribute__((__noreturn__))
#define UPB_PRINTF(str, first_vararg) __attribute__((format (printf, str, first_vararg)))
#elif defined(_MSC_VER)
#define UPB_NOINLINE
#define UPB_FORCEINLINE
#define UPB_NORETURN __declspec(noreturn)
#define UPB_PRINTF(str, first_vararg)
#else  /* !defined(__GNUC__) */
#define UPB_FORCEINLINE
#define UPB_NOINLINE
#define UPB_NORETURN
#define UPB_PRINTF(str, first_vararg)
#endif

#define UPB_MAX(x, y) ((x) > (y) ? (x) : (y))
#define UPB_MIN(x, y) ((x) < (y) ? (x) : (y))

#define UPB_UNUSED(var) (void)var

/* UPB_ASSUME(): in release mode, we tell the compiler to assume this is true.
 */
#ifdef NDEBUG
#ifdef __GNUC__
#define UPB_ASSUME(expr) if (!(expr)) __builtin_unreachable()
#elif defined _MSC_VER
#define UPB_ASSUME(expr) if (!(expr)) __assume(0)
#else
#define UPB_ASSUME(expr) do {} while (false && (expr))
#endif
#else
#define UPB_ASSUME(expr) assert(expr)
#endif

/* UPB_ASSERT(): in release mode, we use the expression without letting it be
 * evaluated.  This prevents "unused variable" warnings. */
#ifdef NDEBUG
#define UPB_ASSERT(expr) do {} while (false && (expr))
#else
#define UPB_ASSERT(expr) assert(expr)
#endif

#if defined(__GNUC__) || defined(__clang__)
#define UPB_UNREACHABLE() do { assert(0); __builtin_unreachable(); } while(0)
#else
#define UPB_UNREACHABLE() do { assert(0); } while(0)
#endif

/* UPB_SETJMP() / UPB_LONGJMP(): avoid setting/restoring signal mask. */
#ifdef __APPLE__
#define UPB_SETJMP(buf) _setjmp(buf)
#define UPB_LONGJMP(buf, val) _longjmp(buf, val)
#else
#define UPB_SETJMP(buf) setjmp(buf)
#define UPB_LONGJMP(buf, val) longjmp(buf, val)
#endif

/* UPB_PTRADD(ptr, ofs): add pointer while avoiding "NULL + 0" UB */
#define UPB_PTRADD(ptr, ofs) ((ofs) ? (ptr) + (ofs) : (ptr))

/* Configure whether fasttable is switched on or not. *************************/

#ifdef __has_attribute
#define UPB_HAS_ATTRIBUTE(x) __has_attribute(x)
#else
#define UPB_HAS_ATTRIBUTE(x) 0
#endif

#if UPB_HAS_ATTRIBUTE(musttail)
#define UPB_MUSTTAIL __attribute__((musttail))
#else
#define UPB_MUSTTAIL
#endif

#undef UPB_HAS_ATTRIBUTE

/* This check is not fully robust: it does not require that we have "musttail"
 * support available. We need tail calls to avoid consuming arbitrary amounts
 * of stack space.
 *
 * GCC/Clang can mostly be trusted to generate tail calls as long as
 * optimization is enabled, but, debug builds will not generate tail calls
 * unless "musttail" is available.
 *
 * We should probably either:
 *   1. require that the compiler supports musttail.
 *   2. add some fallback code for when musttail isn't available (ie. return
 *      instead of tail calling). This is safe and portable, but this comes at
 *      a CPU cost.
 */
#if (defined(__x86_64__) || defined(__aarch64__)) && defined(__GNUC__)
#define UPB_FASTTABLE_SUPPORTED 1
#else
#define UPB_FASTTABLE_SUPPORTED 0
#endif

/* define UPB_ENABLE_FASTTABLE to force fast table support.
 * This is useful when we want to ensure we are really getting fasttable,
 * for example for testing or benchmarking. */
#if defined(UPB_ENABLE_FASTTABLE)
#if !UPB_FASTTABLE_SUPPORTED
#error fasttable is x86-64/ARM64 only and requires GCC or Clang.
#endif
#define UPB_FASTTABLE 1
/* Define UPB_TRY_ENABLE_FASTTABLE to use fasttable if possible.
 * This is useful for releasing code that might be used on multiple platforms,
 * for example the PHP or Ruby C extensions. */
#elif defined(UPB_TRY_ENABLE_FASTTABLE)
#define UPB_FASTTABLE UPB_FASTTABLE_SUPPORTED
#else
#define UPB_FASTTABLE 0
#endif

/* UPB_FASTTABLE_INIT() allows protos compiled for fasttable to gracefully
 * degrade to non-fasttable if we are using UPB_TRY_ENABLE_FASTTABLE. */
#if !UPB_FASTTABLE && defined(UPB_TRY_ENABLE_FASTTABLE)
#define UPB_FASTTABLE_INIT(...)
#else
#define UPB_FASTTABLE_INIT(...) __VA_ARGS__
#endif

#undef UPB_FASTTABLE_SUPPORTED

/* ASAN poisoning (for arena) *************************************************/

#if defined(__SANITIZE_ADDRESS__)
#define UPB_ASAN 1
#ifdef __cplusplus
extern "C" {
#endif
void __asan_poison_memory_region(void const volatile *addr, size_t size);
void __asan_unpoison_memory_region(void const volatile *addr, size_t size);
#ifdef __cplusplus
}  /* extern "C" */
#endif
#define UPB_POISON_MEMORY_REGION(addr, size) \
  __asan_poison_memory_region((addr), (size))
#define UPB_UNPOISON_MEMORY_REGION(addr, size) \
  __asan_unpoison_memory_region((addr), (size))
#else
#define UPB_ASAN 0
#define UPB_POISON_MEMORY_REGION(addr, size) \
  ((void)(addr), (void)(size))
#define UPB_UNPOISON_MEMORY_REGION(addr, size) \
  ((void)(addr), (void)(size))
#endif


#ifdef __cplusplus
extern "C" {
#endif

struct perftools_profiles_Profile;
struct perftools_profiles_ValueType;
struct perftools_profiles_Sample;
struct perftools_profiles_Label;
struct perftools_profiles_Mapping;
struct perftools_profiles_Location;
struct perftools_profiles_Line;
struct perftools_profiles_Function;
typedef struct perftools_profiles_Profile perftools_profiles_Profile;
typedef struct perftools_profiles_ValueType perftools_profiles_ValueType;
typedef struct perftools_profiles_Sample perftools_profiles_Sample;
typedef struct perftools_profiles_Label perftools_profiles_Label;
typedef struct perftools_profiles_Mapping perftools_profiles_Mapping;
typedef struct perftools_profiles_Location perftools_profiles_Location;
typedef struct perftools_profiles_Line perftools_profiles_Line;
typedef struct perftools_profiles_Function perftools_profiles_Function;
extern const upb_msglayout perftools_profiles_Profile_msginit;
extern const upb_msglayout perftools_profiles_ValueType_msginit;
extern const upb_msglayout perftools_profiles_Sample_msginit;
extern const upb_msglayout perftools_profiles_Label_msginit;
extern const upb_msglayout perftools_profiles_Mapping_msginit;
extern const upb_msglayout perftools_profiles_Location_msginit;
extern const upb_msglayout perftools_profiles_Line_msginit;
extern const upb_msglayout perftools_profiles_Function_msginit;



/* perftools.profiles.Profile */

UPB_INLINE perftools_profiles_Profile *perftools_profiles_Profile_new(upb_arena *arena) {
  return (perftools_profiles_Profile *)_upb_msg_new(&perftools_profiles_Profile_msginit, arena);
}
UPB_INLINE perftools_profiles_Profile *perftools_profiles_Profile_parse(const char *buf, size_t size, upb_arena *arena) {
  perftools_profiles_Profile *ret = perftools_profiles_Profile_new(arena);
  if (!ret) return NULL;
  if (upb_decode(buf, size, ret, &perftools_profiles_Profile_msginit, arena) != kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE perftools_profiles_Profile *perftools_profiles_Profile_parse_ex(const char *buf, size_t size,
                           const upb_extreg *extreg, int options,
                           upb_arena *arena) {
  perftools_profiles_Profile *ret = perftools_profiles_Profile_new(arena);
  if (!ret) return NULL;
  if (_upb_decode(buf, size, ret, &perftools_profiles_Profile_msginit, extreg, options, arena) !=
      kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE char *perftools_profiles_Profile_serialize(const perftools_profiles_Profile *msg, upb_arena *arena, size_t *len) {
  return upb_encode(msg, &perftools_profiles_Profile_msginit, arena, len);
}
UPB_INLINE char *perftools_profiles_Profile_serialize_ex(const perftools_profiles_Profile *msg,
                                 int options,
                                 upb_arena *arena,
                                 size_t *len) {
  return upb_encode_ex(msg, &perftools_profiles_Profile_msginit, options, arena, len);
}
UPB_INLINE bool perftools_profiles_Profile_has_sample_type(const perftools_profiles_Profile *msg) { return _upb_has_submsg_nohasbit(msg, UPB_SIZE(60, 64)); }
UPB_INLINE const perftools_profiles_ValueType* const* perftools_profiles_Profile_sample_type(const perftools_profiles_Profile *msg, size_t *len) { return (const perftools_profiles_ValueType* const*)_upb_array_accessor(msg, UPB_SIZE(60, 64), len); }
UPB_INLINE bool perftools_profiles_Profile_has_sample(const perftools_profiles_Profile *msg) { return _upb_has_submsg_nohasbit(msg, UPB_SIZE(64, 72)); }
UPB_INLINE const perftools_profiles_Sample* const* perftools_profiles_Profile_sample(const perftools_profiles_Profile *msg, size_t *len) { return (const perftools_profiles_Sample* const*)_upb_array_accessor(msg, UPB_SIZE(64, 72), len); }
UPB_INLINE bool perftools_profiles_Profile_has_mapping(const perftools_profiles_Profile *msg) { return _upb_has_submsg_nohasbit(msg, UPB_SIZE(68, 80)); }
UPB_INLINE const perftools_profiles_Mapping* const* perftools_profiles_Profile_mapping(const perftools_profiles_Profile *msg, size_t *len) { return (const perftools_profiles_Mapping* const*)_upb_array_accessor(msg, UPB_SIZE(68, 80), len); }
UPB_INLINE bool perftools_profiles_Profile_has_location(const perftools_profiles_Profile *msg) { return _upb_has_submsg_nohasbit(msg, UPB_SIZE(72, 88)); }
UPB_INLINE const perftools_profiles_Location* const* perftools_profiles_Profile_location(const perftools_profiles_Profile *msg, size_t *len) { return (const perftools_profiles_Location* const*)_upb_array_accessor(msg, UPB_SIZE(72, 88), len); }
UPB_INLINE bool perftools_profiles_Profile_has_function(const perftools_profiles_Profile *msg) { return _upb_has_submsg_nohasbit(msg, UPB_SIZE(76, 96)); }
UPB_INLINE const perftools_profiles_Function* const* perftools_profiles_Profile_function(const perftools_profiles_Profile *msg, size_t *len) { return (const perftools_profiles_Function* const*)_upb_array_accessor(msg, UPB_SIZE(76, 96), len); }
UPB_INLINE upb_strview const* perftools_profiles_Profile_string_table(const perftools_profiles_Profile *msg, size_t *len) { return (upb_strview const*)_upb_array_accessor(msg, UPB_SIZE(80, 104), len); }
UPB_INLINE int64_t perftools_profiles_Profile_drop_frames(const perftools_profiles_Profile *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(8, 8), int64_t);
}
UPB_INLINE int64_t perftools_profiles_Profile_keep_frames(const perftools_profiles_Profile *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(16, 16), int64_t);
}
UPB_INLINE int64_t perftools_profiles_Profile_time_nanos(const perftools_profiles_Profile *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(24, 24), int64_t);
}
UPB_INLINE int64_t perftools_profiles_Profile_duration_nanos(const perftools_profiles_Profile *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(32, 32), int64_t);
}
UPB_INLINE bool perftools_profiles_Profile_has_period_type(const perftools_profiles_Profile *msg) { return _upb_hasbit(msg, 1); }
UPB_INLINE const perftools_profiles_ValueType* perftools_profiles_Profile_period_type(const perftools_profiles_Profile *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(56, 56), const perftools_profiles_ValueType*);
}
UPB_INLINE int64_t perftools_profiles_Profile_period(const perftools_profiles_Profile *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(40, 40), int64_t);
}
UPB_INLINE int64_t const* perftools_profiles_Profile_comment(const perftools_profiles_Profile *msg, size_t *len) { return (int64_t const*)_upb_array_accessor(msg, UPB_SIZE(84, 112), len); }
UPB_INLINE int64_t perftools_profiles_Profile_default_sample_type(const perftools_profiles_Profile *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(48, 48), int64_t);
}

UPB_INLINE perftools_profiles_ValueType** perftools_profiles_Profile_mutable_sample_type(perftools_profiles_Profile *msg, size_t *len) {
  return (perftools_profiles_ValueType**)_upb_array_mutable_accessor(msg, UPB_SIZE(60, 64), len);
}
UPB_INLINE perftools_profiles_ValueType** perftools_profiles_Profile_resize_sample_type(perftools_profiles_Profile *msg, size_t len, upb_arena *arena) {
  return (perftools_profiles_ValueType**)_upb_array_resize_accessor2(msg, UPB_SIZE(60, 64), len, UPB_SIZE(2, 3), arena);
}
UPB_INLINE struct perftools_profiles_ValueType* perftools_profiles_Profile_add_sample_type(perftools_profiles_Profile *msg, upb_arena *arena) {
  struct perftools_profiles_ValueType* sub = (struct perftools_profiles_ValueType*)_upb_msg_new(&perftools_profiles_ValueType_msginit, arena);
  bool ok = _upb_array_append_accessor2(
      msg, UPB_SIZE(60, 64), UPB_SIZE(2, 3), &sub, arena);
  if (!ok) return NULL;
  return sub;
}
UPB_INLINE perftools_profiles_Sample** perftools_profiles_Profile_mutable_sample(perftools_profiles_Profile *msg, size_t *len) {
  return (perftools_profiles_Sample**)_upb_array_mutable_accessor(msg, UPB_SIZE(64, 72), len);
}
UPB_INLINE perftools_profiles_Sample** perftools_profiles_Profile_resize_sample(perftools_profiles_Profile *msg, size_t len, upb_arena *arena) {
  return (perftools_profiles_Sample**)_upb_array_resize_accessor2(msg, UPB_SIZE(64, 72), len, UPB_SIZE(2, 3), arena);
}
UPB_INLINE struct perftools_profiles_Sample* perftools_profiles_Profile_add_sample(perftools_profiles_Profile *msg, upb_arena *arena) {
  struct perftools_profiles_Sample* sub = (struct perftools_profiles_Sample*)_upb_msg_new(&perftools_profiles_Sample_msginit, arena);
  bool ok = _upb_array_append_accessor2(
      msg, UPB_SIZE(64, 72), UPB_SIZE(2, 3), &sub, arena);
  if (!ok) return NULL;
  return sub;
}
UPB_INLINE perftools_profiles_Mapping** perftools_profiles_Profile_mutable_mapping(perftools_profiles_Profile *msg, size_t *len) {
  return (perftools_profiles_Mapping**)_upb_array_mutable_accessor(msg, UPB_SIZE(68, 80), len);
}
UPB_INLINE perftools_profiles_Mapping** perftools_profiles_Profile_resize_mapping(perftools_profiles_Profile *msg, size_t len, upb_arena *arena) {
  return (perftools_profiles_Mapping**)_upb_array_resize_accessor2(msg, UPB_SIZE(68, 80), len, UPB_SIZE(2, 3), arena);
}
UPB_INLINE struct perftools_profiles_Mapping* perftools_profiles_Profile_add_mapping(perftools_profiles_Profile *msg, upb_arena *arena) {
  struct perftools_profiles_Mapping* sub = (struct perftools_profiles_Mapping*)_upb_msg_new(&perftools_profiles_Mapping_msginit, arena);
  bool ok = _upb_array_append_accessor2(
      msg, UPB_SIZE(68, 80), UPB_SIZE(2, 3), &sub, arena);
  if (!ok) return NULL;
  return sub;
}
UPB_INLINE perftools_profiles_Location** perftools_profiles_Profile_mutable_location(perftools_profiles_Profile *msg, size_t *len) {
  return (perftools_profiles_Location**)_upb_array_mutable_accessor(msg, UPB_SIZE(72, 88), len);
}
UPB_INLINE perftools_profiles_Location** perftools_profiles_Profile_resize_location(perftools_profiles_Profile *msg, size_t len, upb_arena *arena) {
  return (perftools_profiles_Location**)_upb_array_resize_accessor2(msg, UPB_SIZE(72, 88), len, UPB_SIZE(2, 3), arena);
}
UPB_INLINE struct perftools_profiles_Location* perftools_profiles_Profile_add_location(perftools_profiles_Profile *msg, upb_arena *arena) {
  struct perftools_profiles_Location* sub = (struct perftools_profiles_Location*)_upb_msg_new(&perftools_profiles_Location_msginit, arena);
  bool ok = _upb_array_append_accessor2(
      msg, UPB_SIZE(72, 88), UPB_SIZE(2, 3), &sub, arena);
  if (!ok) return NULL;
  return sub;
}
UPB_INLINE perftools_profiles_Function** perftools_profiles_Profile_mutable_function(perftools_profiles_Profile *msg, size_t *len) {
  return (perftools_profiles_Function**)_upb_array_mutable_accessor(msg, UPB_SIZE(76, 96), len);
}
UPB_INLINE perftools_profiles_Function** perftools_profiles_Profile_resize_function(perftools_profiles_Profile *msg, size_t len, upb_arena *arena) {
  return (perftools_profiles_Function**)_upb_array_resize_accessor2(msg, UPB_SIZE(76, 96), len, UPB_SIZE(2, 3), arena);
}
UPB_INLINE struct perftools_profiles_Function* perftools_profiles_Profile_add_function(perftools_profiles_Profile *msg, upb_arena *arena) {
  struct perftools_profiles_Function* sub = (struct perftools_profiles_Function*)_upb_msg_new(&perftools_profiles_Function_msginit, arena);
  bool ok = _upb_array_append_accessor2(
      msg, UPB_SIZE(76, 96), UPB_SIZE(2, 3), &sub, arena);
  if (!ok) return NULL;
  return sub;
}
UPB_INLINE upb_strview* perftools_profiles_Profile_mutable_string_table(perftools_profiles_Profile *msg, size_t *len) {
  return (upb_strview*)_upb_array_mutable_accessor(msg, UPB_SIZE(80, 104), len);
}
UPB_INLINE upb_strview* perftools_profiles_Profile_resize_string_table(perftools_profiles_Profile *msg, size_t len, upb_arena *arena) {
  return (upb_strview*)_upb_array_resize_accessor2(msg, UPB_SIZE(80, 104), len, UPB_SIZE(3, 4), arena);
}
UPB_INLINE bool perftools_profiles_Profile_add_string_table(perftools_profiles_Profile *msg, upb_strview val, upb_arena *arena) {
  return _upb_array_append_accessor2(msg, UPB_SIZE(80, 104), UPB_SIZE(3, 4), &val,
      arena);
}
UPB_INLINE void perftools_profiles_Profile_set_drop_frames(perftools_profiles_Profile *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(8, 8), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Profile_set_keep_frames(perftools_profiles_Profile *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(16, 16), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Profile_set_time_nanos(perftools_profiles_Profile *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(24, 24), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Profile_set_duration_nanos(perftools_profiles_Profile *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(32, 32), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Profile_set_period_type(perftools_profiles_Profile *msg, perftools_profiles_ValueType* value) {
  _upb_sethas(msg, 1);
  *UPB_PTR_AT(msg, UPB_SIZE(56, 56), perftools_profiles_ValueType*) = value;
}
UPB_INLINE struct perftools_profiles_ValueType* perftools_profiles_Profile_mutable_period_type(perftools_profiles_Profile *msg, upb_arena *arena) {
  struct perftools_profiles_ValueType* sub = (struct perftools_profiles_ValueType*)perftools_profiles_Profile_period_type(msg);
  if (sub == NULL) {
    sub = (struct perftools_profiles_ValueType*)_upb_msg_new(&perftools_profiles_ValueType_msginit, arena);
    if (!sub) return NULL;
    perftools_profiles_Profile_set_period_type(msg, sub);
  }
  return sub;
}
UPB_INLINE void perftools_profiles_Profile_set_period(perftools_profiles_Profile *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(40, 40), int64_t) = value;
}
UPB_INLINE int64_t* perftools_profiles_Profile_mutable_comment(perftools_profiles_Profile *msg, size_t *len) {
  return (int64_t*)_upb_array_mutable_accessor(msg, UPB_SIZE(84, 112), len);
}
UPB_INLINE int64_t* perftools_profiles_Profile_resize_comment(perftools_profiles_Profile *msg, size_t len, upb_arena *arena) {
  return (int64_t*)_upb_array_resize_accessor2(msg, UPB_SIZE(84, 112), len, 3, arena);
}
UPB_INLINE bool perftools_profiles_Profile_add_comment(perftools_profiles_Profile *msg, int64_t val, upb_arena *arena) {
  return _upb_array_append_accessor2(msg, UPB_SIZE(84, 112), 3, &val,
      arena);
}
UPB_INLINE void perftools_profiles_Profile_set_default_sample_type(perftools_profiles_Profile *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(48, 48), int64_t) = value;
}

/* perftools.profiles.ValueType */

UPB_INLINE perftools_profiles_ValueType *perftools_profiles_ValueType_new(upb_arena *arena) {
  return (perftools_profiles_ValueType *)_upb_msg_new(&perftools_profiles_ValueType_msginit, arena);
}
UPB_INLINE perftools_profiles_ValueType *perftools_profiles_ValueType_parse(const char *buf, size_t size, upb_arena *arena) {
  perftools_profiles_ValueType *ret = perftools_profiles_ValueType_new(arena);
  if (!ret) return NULL;
  if (upb_decode(buf, size, ret, &perftools_profiles_ValueType_msginit, arena) != kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE perftools_profiles_ValueType *perftools_profiles_ValueType_parse_ex(const char *buf, size_t size,
                           const upb_extreg *extreg, int options,
                           upb_arena *arena) {
  perftools_profiles_ValueType *ret = perftools_profiles_ValueType_new(arena);
  if (!ret) return NULL;
  if (_upb_decode(buf, size, ret, &perftools_profiles_ValueType_msginit, extreg, options, arena) !=
      kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE char *perftools_profiles_ValueType_serialize(const perftools_profiles_ValueType *msg, upb_arena *arena, size_t *len) {
  return upb_encode(msg, &perftools_profiles_ValueType_msginit, arena, len);
}
UPB_INLINE char *perftools_profiles_ValueType_serialize_ex(const perftools_profiles_ValueType *msg,
                                 int options,
                                 upb_arena *arena,
                                 size_t *len) {
  return upb_encode_ex(msg, &perftools_profiles_ValueType_msginit, options, arena, len);
}
UPB_INLINE int64_t perftools_profiles_ValueType_type(const perftools_profiles_ValueType *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(0, 0), int64_t);
}
UPB_INLINE int64_t perftools_profiles_ValueType_unit(const perftools_profiles_ValueType *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(8, 8), int64_t);
}

UPB_INLINE void perftools_profiles_ValueType_set_type(perftools_profiles_ValueType *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(0, 0), int64_t) = value;
}
UPB_INLINE void perftools_profiles_ValueType_set_unit(perftools_profiles_ValueType *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(8, 8), int64_t) = value;
}

/* perftools.profiles.Sample */

UPB_INLINE perftools_profiles_Sample *perftools_profiles_Sample_new(upb_arena *arena) {
  return (perftools_profiles_Sample *)_upb_msg_new(&perftools_profiles_Sample_msginit, arena);
}
UPB_INLINE perftools_profiles_Sample *perftools_profiles_Sample_parse(const char *buf, size_t size, upb_arena *arena) {
  perftools_profiles_Sample *ret = perftools_profiles_Sample_new(arena);
  if (!ret) return NULL;
  if (upb_decode(buf, size, ret, &perftools_profiles_Sample_msginit, arena) != kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE perftools_profiles_Sample *perftools_profiles_Sample_parse_ex(const char *buf, size_t size,
                           const upb_extreg *extreg, int options,
                           upb_arena *arena) {
  perftools_profiles_Sample *ret = perftools_profiles_Sample_new(arena);
  if (!ret) return NULL;
  if (_upb_decode(buf, size, ret, &perftools_profiles_Sample_msginit, extreg, options, arena) !=
      kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE char *perftools_profiles_Sample_serialize(const perftools_profiles_Sample *msg, upb_arena *arena, size_t *len) {
  return upb_encode(msg, &perftools_profiles_Sample_msginit, arena, len);
}
UPB_INLINE char *perftools_profiles_Sample_serialize_ex(const perftools_profiles_Sample *msg,
                                 int options,
                                 upb_arena *arena,
                                 size_t *len) {
  return upb_encode_ex(msg, &perftools_profiles_Sample_msginit, options, arena, len);
}
UPB_INLINE uint64_t const* perftools_profiles_Sample_location_id(const perftools_profiles_Sample *msg, size_t *len) { return (uint64_t const*)_upb_array_accessor(msg, UPB_SIZE(0, 0), len); }
UPB_INLINE int64_t const* perftools_profiles_Sample_value(const perftools_profiles_Sample *msg, size_t *len) { return (int64_t const*)_upb_array_accessor(msg, UPB_SIZE(4, 8), len); }
UPB_INLINE bool perftools_profiles_Sample_has_label(const perftools_profiles_Sample *msg) { return _upb_has_submsg_nohasbit(msg, UPB_SIZE(8, 16)); }
UPB_INLINE const perftools_profiles_Label* const* perftools_profiles_Sample_label(const perftools_profiles_Sample *msg, size_t *len) { return (const perftools_profiles_Label* const*)_upb_array_accessor(msg, UPB_SIZE(8, 16), len); }

UPB_INLINE uint64_t* perftools_profiles_Sample_mutable_location_id(perftools_profiles_Sample *msg, size_t *len) {
  return (uint64_t*)_upb_array_mutable_accessor(msg, UPB_SIZE(0, 0), len);
}
UPB_INLINE uint64_t* perftools_profiles_Sample_resize_location_id(perftools_profiles_Sample *msg, size_t len, upb_arena *arena) {
  return (uint64_t*)_upb_array_resize_accessor2(msg, UPB_SIZE(0, 0), len, 3, arena);
}
UPB_INLINE bool perftools_profiles_Sample_add_location_id(perftools_profiles_Sample *msg, uint64_t val, upb_arena *arena) {
  return _upb_array_append_accessor2(msg, UPB_SIZE(0, 0), 3, &val,
      arena);
}
UPB_INLINE int64_t* perftools_profiles_Sample_mutable_value(perftools_profiles_Sample *msg, size_t *len) {
  return (int64_t*)_upb_array_mutable_accessor(msg, UPB_SIZE(4, 8), len);
}
UPB_INLINE int64_t* perftools_profiles_Sample_resize_value(perftools_profiles_Sample *msg, size_t len, upb_arena *arena) {
  return (int64_t*)_upb_array_resize_accessor2(msg, UPB_SIZE(4, 8), len, 3, arena);
}
UPB_INLINE bool perftools_profiles_Sample_add_value(perftools_profiles_Sample *msg, int64_t val, upb_arena *arena) {
  return _upb_array_append_accessor2(msg, UPB_SIZE(4, 8), 3, &val,
      arena);
}
UPB_INLINE perftools_profiles_Label** perftools_profiles_Sample_mutable_label(perftools_profiles_Sample *msg, size_t *len) {
  return (perftools_profiles_Label**)_upb_array_mutable_accessor(msg, UPB_SIZE(8, 16), len);
}
UPB_INLINE perftools_profiles_Label** perftools_profiles_Sample_resize_label(perftools_profiles_Sample *msg, size_t len, upb_arena *arena) {
  return (perftools_profiles_Label**)_upb_array_resize_accessor2(msg, UPB_SIZE(8, 16), len, UPB_SIZE(2, 3), arena);
}
UPB_INLINE struct perftools_profiles_Label* perftools_profiles_Sample_add_label(perftools_profiles_Sample *msg, upb_arena *arena) {
  struct perftools_profiles_Label* sub = (struct perftools_profiles_Label*)_upb_msg_new(&perftools_profiles_Label_msginit, arena);
  bool ok = _upb_array_append_accessor2(
      msg, UPB_SIZE(8, 16), UPB_SIZE(2, 3), &sub, arena);
  if (!ok) return NULL;
  return sub;
}

/* perftools.profiles.Label */

UPB_INLINE perftools_profiles_Label *perftools_profiles_Label_new(upb_arena *arena) {
  return (perftools_profiles_Label *)_upb_msg_new(&perftools_profiles_Label_msginit, arena);
}
UPB_INLINE perftools_profiles_Label *perftools_profiles_Label_parse(const char *buf, size_t size, upb_arena *arena) {
  perftools_profiles_Label *ret = perftools_profiles_Label_new(arena);
  if (!ret) return NULL;
  if (upb_decode(buf, size, ret, &perftools_profiles_Label_msginit, arena) != kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE perftools_profiles_Label *perftools_profiles_Label_parse_ex(const char *buf, size_t size,
                           const upb_extreg *extreg, int options,
                           upb_arena *arena) {
  perftools_profiles_Label *ret = perftools_profiles_Label_new(arena);
  if (!ret) return NULL;
  if (_upb_decode(buf, size, ret, &perftools_profiles_Label_msginit, extreg, options, arena) !=
      kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE char *perftools_profiles_Label_serialize(const perftools_profiles_Label *msg, upb_arena *arena, size_t *len) {
  return upb_encode(msg, &perftools_profiles_Label_msginit, arena, len);
}
UPB_INLINE char *perftools_profiles_Label_serialize_ex(const perftools_profiles_Label *msg,
                                 int options,
                                 upb_arena *arena,
                                 size_t *len) {
  return upb_encode_ex(msg, &perftools_profiles_Label_msginit, options, arena, len);
}
UPB_INLINE int64_t perftools_profiles_Label_key(const perftools_profiles_Label *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(0, 0), int64_t);
}
UPB_INLINE int64_t perftools_profiles_Label_str(const perftools_profiles_Label *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(8, 8), int64_t);
}
UPB_INLINE int64_t perftools_profiles_Label_num(const perftools_profiles_Label *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(16, 16), int64_t);
}
UPB_INLINE int64_t perftools_profiles_Label_num_unit(const perftools_profiles_Label *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(24, 24), int64_t);
}

UPB_INLINE void perftools_profiles_Label_set_key(perftools_profiles_Label *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(0, 0), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Label_set_str(perftools_profiles_Label *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(8, 8), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Label_set_num(perftools_profiles_Label *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(16, 16), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Label_set_num_unit(perftools_profiles_Label *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(24, 24), int64_t) = value;
}

/* perftools.profiles.Mapping */

UPB_INLINE perftools_profiles_Mapping *perftools_profiles_Mapping_new(upb_arena *arena) {
  return (perftools_profiles_Mapping *)_upb_msg_new(&perftools_profiles_Mapping_msginit, arena);
}
UPB_INLINE perftools_profiles_Mapping *perftools_profiles_Mapping_parse(const char *buf, size_t size, upb_arena *arena) {
  perftools_profiles_Mapping *ret = perftools_profiles_Mapping_new(arena);
  if (!ret) return NULL;
  if (upb_decode(buf, size, ret, &perftools_profiles_Mapping_msginit, arena) != kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE perftools_profiles_Mapping *perftools_profiles_Mapping_parse_ex(const char *buf, size_t size,
                           const upb_extreg *extreg, int options,
                           upb_arena *arena) {
  perftools_profiles_Mapping *ret = perftools_profiles_Mapping_new(arena);
  if (!ret) return NULL;
  if (_upb_decode(buf, size, ret, &perftools_profiles_Mapping_msginit, extreg, options, arena) !=
      kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE char *perftools_profiles_Mapping_serialize(const perftools_profiles_Mapping *msg, upb_arena *arena, size_t *len) {
  return upb_encode(msg, &perftools_profiles_Mapping_msginit, arena, len);
}
UPB_INLINE char *perftools_profiles_Mapping_serialize_ex(const perftools_profiles_Mapping *msg,
                                 int options,
                                 upb_arena *arena,
                                 size_t *len) {
  return upb_encode_ex(msg, &perftools_profiles_Mapping_msginit, options, arena, len);
}
UPB_INLINE uint64_t perftools_profiles_Mapping_id(const perftools_profiles_Mapping *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(0, 0), uint64_t);
}
UPB_INLINE uint64_t perftools_profiles_Mapping_memory_start(const perftools_profiles_Mapping *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(8, 8), uint64_t);
}
UPB_INLINE uint64_t perftools_profiles_Mapping_memory_limit(const perftools_profiles_Mapping *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(16, 16), uint64_t);
}
UPB_INLINE uint64_t perftools_profiles_Mapping_file_offset(const perftools_profiles_Mapping *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(24, 24), uint64_t);
}
UPB_INLINE int64_t perftools_profiles_Mapping_filename(const perftools_profiles_Mapping *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(32, 32), int64_t);
}
UPB_INLINE int64_t perftools_profiles_Mapping_build_id(const perftools_profiles_Mapping *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(40, 40), int64_t);
}
UPB_INLINE bool perftools_profiles_Mapping_has_functions(const perftools_profiles_Mapping *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(48, 48), bool);
}
UPB_INLINE bool perftools_profiles_Mapping_has_filenames(const perftools_profiles_Mapping *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(49, 49), bool);
}
UPB_INLINE bool perftools_profiles_Mapping_has_line_numbers(const perftools_profiles_Mapping *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(50, 50), bool);
}
UPB_INLINE bool perftools_profiles_Mapping_has_inline_frames(const perftools_profiles_Mapping *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(51, 51), bool);
}

UPB_INLINE void perftools_profiles_Mapping_set_id(perftools_profiles_Mapping *msg, uint64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(0, 0), uint64_t) = value;
}
UPB_INLINE void perftools_profiles_Mapping_set_memory_start(perftools_profiles_Mapping *msg, uint64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(8, 8), uint64_t) = value;
}
UPB_INLINE void perftools_profiles_Mapping_set_memory_limit(perftools_profiles_Mapping *msg, uint64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(16, 16), uint64_t) = value;
}
UPB_INLINE void perftools_profiles_Mapping_set_file_offset(perftools_profiles_Mapping *msg, uint64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(24, 24), uint64_t) = value;
}
UPB_INLINE void perftools_profiles_Mapping_set_filename(perftools_profiles_Mapping *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(32, 32), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Mapping_set_build_id(perftools_profiles_Mapping *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(40, 40), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Mapping_set_has_functions(perftools_profiles_Mapping *msg, bool value) {
  *UPB_PTR_AT(msg, UPB_SIZE(48, 48), bool) = value;
}
UPB_INLINE void perftools_profiles_Mapping_set_has_filenames(perftools_profiles_Mapping *msg, bool value) {
  *UPB_PTR_AT(msg, UPB_SIZE(49, 49), bool) = value;
}
UPB_INLINE void perftools_profiles_Mapping_set_has_line_numbers(perftools_profiles_Mapping *msg, bool value) {
  *UPB_PTR_AT(msg, UPB_SIZE(50, 50), bool) = value;
}
UPB_INLINE void perftools_profiles_Mapping_set_has_inline_frames(perftools_profiles_Mapping *msg, bool value) {
  *UPB_PTR_AT(msg, UPB_SIZE(51, 51), bool) = value;
}

/* perftools.profiles.Location */

UPB_INLINE perftools_profiles_Location *perftools_profiles_Location_new(upb_arena *arena) {
  return (perftools_profiles_Location *)_upb_msg_new(&perftools_profiles_Location_msginit, arena);
}
UPB_INLINE perftools_profiles_Location *perftools_profiles_Location_parse(const char *buf, size_t size, upb_arena *arena) {
  perftools_profiles_Location *ret = perftools_profiles_Location_new(arena);
  if (!ret) return NULL;
  if (upb_decode(buf, size, ret, &perftools_profiles_Location_msginit, arena) != kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE perftools_profiles_Location *perftools_profiles_Location_parse_ex(const char *buf, size_t size,
                           const upb_extreg *extreg, int options,
                           upb_arena *arena) {
  perftools_profiles_Location *ret = perftools_profiles_Location_new(arena);
  if (!ret) return NULL;
  if (_upb_decode(buf, size, ret, &perftools_profiles_Location_msginit, extreg, options, arena) !=
      kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE char *perftools_profiles_Location_serialize(const perftools_profiles_Location *msg, upb_arena *arena, size_t *len) {
  return upb_encode(msg, &perftools_profiles_Location_msginit, arena, len);
}
UPB_INLINE char *perftools_profiles_Location_serialize_ex(const perftools_profiles_Location *msg,
                                 int options,
                                 upb_arena *arena,
                                 size_t *len) {
  return upb_encode_ex(msg, &perftools_profiles_Location_msginit, options, arena, len);
}
UPB_INLINE uint64_t perftools_profiles_Location_id(const perftools_profiles_Location *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(0, 0), uint64_t);
}
UPB_INLINE uint64_t perftools_profiles_Location_mapping_id(const perftools_profiles_Location *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(8, 8), uint64_t);
}
UPB_INLINE uint64_t perftools_profiles_Location_address(const perftools_profiles_Location *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(16, 16), uint64_t);
}
UPB_INLINE bool perftools_profiles_Location_has_line(const perftools_profiles_Location *msg) { return _upb_has_submsg_nohasbit(msg, UPB_SIZE(28, 32)); }
UPB_INLINE const perftools_profiles_Line* const* perftools_profiles_Location_line(const perftools_profiles_Location *msg, size_t *len) { return (const perftools_profiles_Line* const*)_upb_array_accessor(msg, UPB_SIZE(28, 32), len); }
UPB_INLINE bool perftools_profiles_Location_is_folded(const perftools_profiles_Location *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(24, 24), bool);
}

UPB_INLINE void perftools_profiles_Location_set_id(perftools_profiles_Location *msg, uint64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(0, 0), uint64_t) = value;
}
UPB_INLINE void perftools_profiles_Location_set_mapping_id(perftools_profiles_Location *msg, uint64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(8, 8), uint64_t) = value;
}
UPB_INLINE void perftools_profiles_Location_set_address(perftools_profiles_Location *msg, uint64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(16, 16), uint64_t) = value;
}
UPB_INLINE perftools_profiles_Line** perftools_profiles_Location_mutable_line(perftools_profiles_Location *msg, size_t *len) {
  return (perftools_profiles_Line**)_upb_array_mutable_accessor(msg, UPB_SIZE(28, 32), len);
}
UPB_INLINE perftools_profiles_Line** perftools_profiles_Location_resize_line(perftools_profiles_Location *msg, size_t len, upb_arena *arena) {
  return (perftools_profiles_Line**)_upb_array_resize_accessor2(msg, UPB_SIZE(28, 32), len, UPB_SIZE(2, 3), arena);
}
UPB_INLINE struct perftools_profiles_Line* perftools_profiles_Location_add_line(perftools_profiles_Location *msg, upb_arena *arena) {
  struct perftools_profiles_Line* sub = (struct perftools_profiles_Line*)_upb_msg_new(&perftools_profiles_Line_msginit, arena);
  bool ok = _upb_array_append_accessor2(
      msg, UPB_SIZE(28, 32), UPB_SIZE(2, 3), &sub, arena);
  if (!ok) return NULL;
  return sub;
}
UPB_INLINE void perftools_profiles_Location_set_is_folded(perftools_profiles_Location *msg, bool value) {
  *UPB_PTR_AT(msg, UPB_SIZE(24, 24), bool) = value;
}

/* perftools.profiles.Line */

UPB_INLINE perftools_profiles_Line *perftools_profiles_Line_new(upb_arena *arena) {
  return (perftools_profiles_Line *)_upb_msg_new(&perftools_profiles_Line_msginit, arena);
}
UPB_INLINE perftools_profiles_Line *perftools_profiles_Line_parse(const char *buf, size_t size, upb_arena *arena) {
  perftools_profiles_Line *ret = perftools_profiles_Line_new(arena);
  if (!ret) return NULL;
  if (upb_decode(buf, size, ret, &perftools_profiles_Line_msginit, arena) != kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE perftools_profiles_Line *perftools_profiles_Line_parse_ex(const char *buf, size_t size,
                           const upb_extreg *extreg, int options,
                           upb_arena *arena) {
  perftools_profiles_Line *ret = perftools_profiles_Line_new(arena);
  if (!ret) return NULL;
  if (_upb_decode(buf, size, ret, &perftools_profiles_Line_msginit, extreg, options, arena) !=
      kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE char *perftools_profiles_Line_serialize(const perftools_profiles_Line *msg, upb_arena *arena, size_t *len) {
  return upb_encode(msg, &perftools_profiles_Line_msginit, arena, len);
}
UPB_INLINE char *perftools_profiles_Line_serialize_ex(const perftools_profiles_Line *msg,
                                 int options,
                                 upb_arena *arena,
                                 size_t *len) {
  return upb_encode_ex(msg, &perftools_profiles_Line_msginit, options, arena, len);
}
UPB_INLINE uint64_t perftools_profiles_Line_function_id(const perftools_profiles_Line *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(0, 0), uint64_t);
}
UPB_INLINE int64_t perftools_profiles_Line_line(const perftools_profiles_Line *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(8, 8), int64_t);
}

UPB_INLINE void perftools_profiles_Line_set_function_id(perftools_profiles_Line *msg, uint64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(0, 0), uint64_t) = value;
}
UPB_INLINE void perftools_profiles_Line_set_line(perftools_profiles_Line *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(8, 8), int64_t) = value;
}

/* perftools.profiles.Function */

UPB_INLINE perftools_profiles_Function *perftools_profiles_Function_new(upb_arena *arena) {
  return (perftools_profiles_Function *)_upb_msg_new(&perftools_profiles_Function_msginit, arena);
}
UPB_INLINE perftools_profiles_Function *perftools_profiles_Function_parse(const char *buf, size_t size, upb_arena *arena) {
  perftools_profiles_Function *ret = perftools_profiles_Function_new(arena);
  if (!ret) return NULL;
  if (upb_decode(buf, size, ret, &perftools_profiles_Function_msginit, arena) != kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE perftools_profiles_Function *perftools_profiles_Function_parse_ex(const char *buf, size_t size,
                           const upb_extreg *extreg, int options,
                           upb_arena *arena) {
  perftools_profiles_Function *ret = perftools_profiles_Function_new(arena);
  if (!ret) return NULL;
  if (_upb_decode(buf, size, ret, &perftools_profiles_Function_msginit, extreg, options, arena) !=
      kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
UPB_INLINE char *perftools_profiles_Function_serialize(const perftools_profiles_Function *msg, upb_arena *arena, size_t *len) {
  return upb_encode(msg, &perftools_profiles_Function_msginit, arena, len);
}
UPB_INLINE char *perftools_profiles_Function_serialize_ex(const perftools_profiles_Function *msg,
                                 int options,
                                 upb_arena *arena,
                                 size_t *len) {
  return upb_encode_ex(msg, &perftools_profiles_Function_msginit, options, arena, len);
}
UPB_INLINE uint64_t perftools_profiles_Function_id(const perftools_profiles_Function *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(0, 0), uint64_t);
}
UPB_INLINE int64_t perftools_profiles_Function_name(const perftools_profiles_Function *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(8, 8), int64_t);
}
UPB_INLINE int64_t perftools_profiles_Function_system_name(const perftools_profiles_Function *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(16, 16), int64_t);
}
UPB_INLINE int64_t perftools_profiles_Function_filename(const perftools_profiles_Function *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(24, 24), int64_t);
}
UPB_INLINE int64_t perftools_profiles_Function_start_line(const perftools_profiles_Function *msg) {
  return *UPB_PTR_AT(msg, UPB_SIZE(32, 32), int64_t);
}

UPB_INLINE void perftools_profiles_Function_set_id(perftools_profiles_Function *msg, uint64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(0, 0), uint64_t) = value;
}
UPB_INLINE void perftools_profiles_Function_set_name(perftools_profiles_Function *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(8, 8), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Function_set_system_name(perftools_profiles_Function *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(16, 16), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Function_set_filename(perftools_profiles_Function *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(24, 24), int64_t) = value;
}
UPB_INLINE void perftools_profiles_Function_set_start_line(perftools_profiles_Function *msg, int64_t value) {
  *UPB_PTR_AT(msg, UPB_SIZE(32, 32), int64_t) = value;
}

extern const upb_msglayout_file pprof_proto_upb_file_layout;

#ifdef __cplusplus
}  /* extern "C" */
#endif
#include "upb.h"

#endif  /* PPROF_PROTO_UPB_H_ */
